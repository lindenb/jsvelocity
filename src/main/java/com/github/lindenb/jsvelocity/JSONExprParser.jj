/**
 * Author:
 * 	Pierre Lindenbaum PhD
 * Date:
 * 	March-2011
 * Contact:
 * 	plindenbaum@yahoo.fr
 * Reference:
 *   
 * WWW:
 * 	http://plindenbaum.blogspot.com
 * Wiki
 *  
 * Motivation:
 * 	process JSON structure with apache velocity
 */
options {
STATIC=false;
}


PARSER_BEGIN(JSONExprParser)

package com.github.lindenb.jsvelocity.json.expr;
import com.github.lindenb.jsvelocity.json.*;
import java.util.*;
import java.io.*;
import java.math.*;

@SuppressWarnings("unchecked")
public class JSONExprParser
{

public static abstract class ExprNode
	{
	protected ExprNode next=null;
	public abstract void eval(JSNode curr,List<JSNode>list);
	
	
	}

private static class RootNode extends ExprNode
	{
	@Override
	public void eval(JSNode node,List<JSNode>list)
		{
		if(node==null) return;
		JSNode root=node.getParentNode();
		if(next!=null)
			{
			next.eval(root, list);
			}
		else
			{
			list.add(root);
			}
		}
	}

private static class SearchObjectFieldNode extends ExprNode
	{
	private String key;
	@Override
	public void eval(JSNode node,List<JSNode>list)
		{
		if(node==null || !node.isObject()) return;
		JSObject m=(JSObject)node;
		if(!m.containsKey(this.key)) return;
		JSNode v=m.get(this.key);
		if(next!=null)
			{
			next.eval(v, list);
			}
		else
			{
			list.add(v);
			}
		}
	}
private static class SearchArrayNode extends ExprNode
	{
	int index;
	@Override
	public void eval(JSNode node,List<JSNode>list)
		{
		if(node==null || !node.isArray()) return;
		JSArray m=(JSArray)node;
		if(index<0 || m.size()<=index) return;
		JSNode v=m.get(index);
		if(next!=null)
			{
			next.eval(v, list);
			}
		else
			{
			list.add(v);
			}
		}
	}



}


PARSER_END(JSONExprParser)

SKIP :
{
" "
| "\t"
| "\n"
| "\r"
}


TOKEN : /* LITERALS */
{
  <SLASH: "/">
| <THIS: "this">
| <EQ: "==">
| <NE: "!=">
| <FALSE: "false">
| <NULL: "null">
| <#LETTER: ["_","a"-"z","A"-"Z"] >
| <#DIGIT: ["0"-"9"] >
| <#SIGN: ["-","+"]>
| <#EXPONENT: ("E"|"e") (<SIGN>)? (<DIGIT>)+ >
| <FLOATING_NUMBER: (<DIGIT>)* "." (<DIGIT>)* (<EXPONENT>)?
| (<DIGIT>)+ (<EXPONENT>) >
| <INTEGER: (<DIGIT>)+ >
| <IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"-")* >
| <#ESCAPE_CHAR: "\\" ["n","t","b","r","f","\\","'","\""] >
| <SIMPLE_QUOTE_LITERAL:
"\'"
( (~["\'","\\","\n","\r"])
| <ESCAPE_CHAR>
)*
"\'"
>
|
<DOUBLE_QUOTE_LITERAL:
"\""
( (~["\"","\\","\n","\r"])
| <ESCAPE_CHAR>
)*
"\""
>
| <ARRAY_OPEN: "[">
| <ARRAY_CLOSE: "]">
}

public ExprNode input():{ExprNode n=null;}
	{ 
		(
		  <SLASH>  ( n=relative())? { RootNode r=new  RootNode(); r.next=n; return r;} 
		| n=relative() { return n;}
		) <EOF>
	}

private ExprNode relative():
	{
	ExprNode ret=null;
	ExprNode e1=null;
	ExprNode e2=null;
	}
	{ 
	e1=pathitem() { ret=e1;} (<SLASH> e2=pathitem() { e1.next=e2; e1=e2;})* { return ret;}
	}

private ExprNode pathitem():{int index;Token t; ExprNode ret=null;}
	{ 
	( t=<IDENTIFIER> {SearchObjectFieldNode n=new SearchObjectFieldNode(); n.key=t.image; ret=n; }
	| <ARRAY_OPEN> index=integer() <ARRAY_CLOSE>  {SearchArrayNode n2=new SearchArrayNode(); n2.index=index;  ret=n; }
	) (having())?
		{
		return ret;
		}
	}

public 	ExprNode having():{}
	{
	<IDENTIFIER> <EQ> <IDENTIFIER>
	}
	
	
private int integer():{Token t;}	
		{
	t=<INTEGER> {
		return Integer.parseInt(t.image);
		}
	}
